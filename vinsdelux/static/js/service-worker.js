/**\n * VinsDelux Service Worker\n * Implements luxury-grade caching strategies and offline functionality\n */\n\nconst CACHE_NAME = 'vinsdelux-v1.0.0';\nconst OFFLINE_URL = '/offline/';\n\n// Assets to cache for offline functionality\nconst STATIC_ASSETS = [\n    '/',\n    '/static/css/enhanced-plot-selector.css',\n    '/static/css/performance-optimized.css',\n    '/static/js/enhanced-plot-selector.js',\n    '/static/js/performance-optimizer.js',\n    '/static/images/logo.png',\n    '/static/images/vineyard-hero.jpg',\n    '/static/fontawesome/css/all.min.css',\n    OFFLINE_URL\n];\n\n// API endpoints to cache with network-first strategy\nconst API_CACHE_PATTERNS = [\n    /\\/api\\/plots\\//,\n    /\\/api\\/adoption-plans\\//,\n    /\\/api\\/producers\\//\n];\n\n// Image cache patterns\nconst IMAGE_CACHE_PATTERNS = [\n    /\\.(?:png|jpg|jpeg|svg|gif|webp)$/,\n    /\\/images\\//,\n    /\\/media\\//\n];\n\n// Font cache patterns\nconst FONT_CACHE_PATTERNS = [\n    /\\.(?:woff|woff2|ttf|eot)$/,\n    /fonts\\.googleapis\\.com/,\n    /fonts\\.gstatic\\.com/\n];\n\n/**\n * Service Worker Installation\n */\nself.addEventListener('install', (event) => {\n    console.log('üç∑ VinsDelux Service Worker installing...');\n    \n    event.waitUntil(\n        caches.open(CACHE_NAME)\n            .then((cache) => {\n                console.log('üì¶ Caching static assets...');\n                return cache.addAll(STATIC_ASSETS);\n            })\n            .then(() => {\n                // Skip waiting to activate immediately\n                return self.skipWaiting();\n            })\n            .catch((error) => {\n                console.error('‚ùå Failed to cache static assets:', error);\n            })\n    );\n});\n\n/**\n * Service Worker Activation\n */\nself.addEventListener('activate', (event) => {\n    console.log('üöÄ VinsDelux Service Worker activating...');\n    \n    event.waitUntil(\n        Promise.all([\n            // Clean up old caches\n            cleanupOldCaches(),\n            // Claim clients immediately\n            self.clients.claim()\n        ])\n    );\n});\n\n/**\n * Fetch Event Handler - Implements caching strategies\n */\nself.addEventListener('fetch', (event) => {\n    const { request } = event;\n    const url = new URL(request.url);\n    \n    // Skip non-GET requests\n    if (request.method !== 'GET') {\n        return;\n    }\n    \n    // Skip chrome-extension requests\n    if (url.protocol === 'chrome-extension:') {\n        return;\n    }\n    \n    // Route to appropriate caching strategy\n    if (isAPIRequest(request)) {\n        event.respondWith(networkFirstStrategy(request));\n    } else if (isImageRequest(request)) {\n        event.respondWith(cacheFirstStrategy(request));\n    } else if (isFontRequest(request)) {\n        event.respondWith(cacheFirstStrategy(request, 'fonts-cache-v1'));\n    } else if (isStaticAsset(request)) {\n        event.respondWith(staleWhileRevalidateStrategy(request));\n    } else if (isNavigationRequest(request)) {\n        event.respondWith(networkFirstWithOfflineFallback(request));\n    } else {\n        // Default to network-first for other requests\n        event.respondWith(networkFirstStrategy(request));\n    }\n});\n\n/**\n * Background Sync for offline actions\n */\nself.addEventListener('sync', (event) => {\n    console.log('üîÑ Background sync triggered:', event.tag);\n    \n    if (event.tag === 'plot-selection-sync') {\n        event.waitUntil(syncPlotSelections());\n    } else if (event.tag === 'analytics-sync') {\n        event.waitUntil(syncAnalytics());\n    }\n});\n\n/**\n * Push notifications for wine updates\n */\nself.addEventListener('push', (event) => {\n    console.log('üì¢ Push notification received:', event.data?.text());\n    \n    const options = {\n        body: event.data?.text() || 'New update from VinsDelux',\n        icon: '/static/images/logo-192x192.png',\n        badge: '/static/images/badge-72x72.png',\n        vibrate: [200, 100, 200],\n        tag: 'vinsdelux-notification',\n        actions: [\n            {\n                action: 'view',\n                title: 'View Details',\n                icon: '/static/images/action-view.png'\n            },\n            {\n                action: 'dismiss',\n                title: 'Dismiss',\n                icon: '/static/images/action-dismiss.png'\n            }\n        ],\n        data: {\n            url: '/journey/plot-selection/',\n            timestamp: Date.now()\n        }\n    };\n    \n    event.waitUntil(\n        self.registration.showNotification('VinsDelux', options)\n    );\n});\n\n/**\n * Notification click handler\n */\nself.addEventListener('notificationclick', (event) => {\n    console.log('üì± Notification clicked:', event.action);\n    \n    event.notification.close();\n    \n    if (event.action === 'view') {\n        const url = event.notification.data?.url || '/';\n        event.waitUntil(\n            clients.openWindow(url)\n        );\n    }\n});\n\n/**\n * CACHING STRATEGIES\n */\n\n/**\n * Network First Strategy\n * Try network first, fall back to cache\n * Good for: API requests, dynamic content\n */\nasync function networkFirstStrategy(request, cacheName = CACHE_NAME) {\n    const cache = await caches.open(cacheName);\n    \n    try {\n        // Try network first\n        const networkResponse = await fetch(request);\n        \n        // Cache successful responses\n        if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n    } catch (error) {\n        // Network failed, try cache\n        const cachedResponse = await cache.match(request);\n        \n        if (cachedResponse) {\n            console.log('üì± Serving from cache:', request.url);\n            return cachedResponse;\n        }\n        \n        // Both network and cache failed\n        console.error('‚ùå Network and cache failed for:', request.url);\n        return createErrorResponse(request);\n    }\n}\n\n/**\n * Cache First Strategy\n * Try cache first, fall back to network\n * Good for: Images, fonts, static assets\n */\nasync function cacheFirstStrategy(request, cacheName = CACHE_NAME) {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n    \n    if (cachedResponse) {\n        console.log('‚ö° Serving from cache:', request.url);\n        return cachedResponse;\n    }\n    \n    try {\n        // Not in cache, fetch from network\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            // Clone and cache the response\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n    } catch (error) {\n        console.error('‚ùå Failed to fetch:', request.url, error);\n        return createErrorResponse(request);\n    }\n}\n\n/**\n * Stale While Revalidate Strategy\n * Serve from cache immediately, update cache in background\n * Good for: CSS, JS, frequently updated content\n */\nasync function staleWhileRevalidateStrategy(request, cacheName = CACHE_NAME) {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n    \n    // Background fetch to update cache\n    const fetchPromise = fetch(request).then((networkResponse) => {\n        if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    }).catch((error) => {\n        console.warn('‚ö†Ô∏è Background fetch failed:', request.url, error);\n    });\n    \n    // Return cached version immediately if available\n    if (cachedResponse) {\n        console.log('‚ö° Serving stale from cache:', request.url);\n        return cachedResponse;\n    }\n    \n    // Wait for network if nothing in cache\n    try {\n        return await fetchPromise;\n    } catch (error) {\n        return createErrorResponse(request);\n    }\n}\n\n/**\n * Network First with Offline Fallback\n * For navigation requests\n */\nasync function networkFirstWithOfflineFallback(request) {\n    try {\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            // Cache successful navigation responses\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n    } catch (error) {\n        // Network failed, try cached version\n        const cache = await caches.open(CACHE_NAME);\n        const cachedResponse = await cache.match(request);\n        \n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Show offline page for navigation requests\n        const offlineResponse = await cache.match(OFFLINE_URL);\n        if (offlineResponse) {\n            return offlineResponse;\n        }\n        \n        return createErrorResponse(request);\n    }\n}\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Clean up old caches\n */\nasync function cleanupOldCaches() {\n    const cacheNames = await caches.keys();\n    const oldCaches = cacheNames.filter(name => \n        name.startsWith('vinsdelux-') && name !== CACHE_NAME\n    );\n    \n    console.log('üßπ Cleaning up old caches:', oldCaches);\n    \n    return Promise.all(\n        oldCaches.map(name => caches.delete(name))\n    );\n}\n\n/**\n * Request type checking functions\n */\nfunction isAPIRequest(request) {\n    return API_CACHE_PATTERNS.some(pattern => \n        pattern.test(request.url)\n    );\n}\n\nfunction isImageRequest(request) {\n    return IMAGE_CACHE_PATTERNS.some(pattern => \n        pattern.test(request.url)\n    );\n}\n\nfunction isFontRequest(request) {\n    return FONT_CACHE_PATTERNS.some(pattern => \n        pattern.test(request.url)\n    );\n}\n\nfunction isStaticAsset(request) {\n    const url = new URL(request.url);\n    return url.pathname.startsWith('/static/') || \n           url.pathname.endsWith('.css') ||\n           url.pathname.endsWith('.js');\n}\n\nfunction isNavigationRequest(request) {\n    return request.mode === 'navigate' || \n           (request.method === 'GET' && request.headers.get('accept')?.includes('text/html'));\n}\n\n/**\n * Create error response for failed requests\n */\nfunction createErrorResponse(request) {\n    const isNavigationRequest = request.mode === 'navigate';\n    \n    if (isNavigationRequest) {\n        return new Response(\n            `<!DOCTYPE html>\n            <html>\n            <head>\n                <title>VinsDelux - Connection Error</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body { font-family: system-ui, sans-serif; text-align: center; padding: 2rem; }\n                    .error-container { max-width: 400px; margin: 0 auto; }\n                    .wine-icon { font-size: 4rem; margin-bottom: 1rem; }\n                </style>\n            </head>\n            <body>\n                <div class=\"error-container\">\n                    <div class=\"wine-icon\">üç∑</div>\n                    <h1>Connection Error</h1>\n                    <p>Unable to load this page. Please check your internet connection and try again.</p>\n                    <button onclick=\"window.location.reload()\">Try Again</button>\n                </div>\n            </body>\n            </html>`,\n            {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: { 'Content-Type': 'text/html' }\n            }\n        );\n    } else {\n        return new Response(\n            JSON.stringify({ error: 'Network unavailable', offline: true }),\n            {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: { 'Content-Type': 'application/json' }\n            }\n        );\n    }\n}\n\n/**\n * Background sync functions\n */\nasync function syncPlotSelections() {\n    console.log('üîÑ Syncing plot selections...');\n    \n    try {\n        // Get stored offline actions\n        const db = await openIndexedDB();\n        const pendingSelections = await getStoredItems(db, 'pendingSelections');\n        \n        for (const selection of pendingSelections) {\n            try {\n                const response = await fetch('/api/plots/selection/', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-CSRFToken': selection.csrfToken\n                    },\n                    body: JSON.stringify(selection.data)\n                });\n                \n                if (response.ok) {\n                    // Remove from pending list\n                    await removeStoredItem(db, 'pendingSelections', selection.id);\n                    console.log('‚úÖ Synced plot selection:', selection.id);\n                } else {\n                    console.warn('‚ö†Ô∏è Failed to sync selection:', selection.id, response.status);\n                }\n            } catch (error) {\n                console.error('‚ùå Error syncing selection:', selection.id, error);\n            }\n        }\n    } catch (error) {\n        console.error('‚ùå Background sync failed:', error);\n    }\n}\n\nasync function syncAnalytics() {\n    console.log('üìä Syncing analytics...');\n    \n    // Implementation for syncing offline analytics\n    // This would sync stored events to your analytics service\n}\n\n/**\n * IndexedDB helpers for offline storage\n */\nfunction openIndexedDB() {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open('VinsDeluxDB', 1);\n        \n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n        \n        request.onupgradeneeded = (event) => {\n            const db = event.target.result;\n            \n            // Create object stores\n            if (!db.objectStoreNames.contains('pendingSelections')) {\n                db.createObjectStore('pendingSelections', { keyPath: 'id' });\n            }\n            \n            if (!db.objectStoreNames.contains('offlineAnalytics')) {\n                db.createObjectStore('offlineAnalytics', { keyPath: 'id' });\n            }\n        };\n    });\n}\n\nfunction getStoredItems(db, storeName) {\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([storeName], 'readonly');\n        const store = transaction.objectStore(storeName);\n        const request = store.getAll();\n        \n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n    });\n}\n\nfunction removeStoredItem(db, storeName, id) {\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([storeName], 'readwrite');\n        const store = transaction.objectStore(storeName);\n        const request = store.delete(id);\n        \n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n    });\n}\n\n/**\n * Message handling for communication with main thread\n */\nself.addEventListener('message', (event) => {\n    const { type, data } = event.data;\n    \n    switch (type) {\n        case 'SKIP_WAITING':\n            self.skipWaiting();\n            break;\n            \n        case 'GET_CACHE_SIZE':\n            getCacheSize().then(size => {\n                event.ports[0].postMessage({ size });\n            });\n            break;\n            \n        case 'CLEAR_CACHE':\n            clearCache().then(() => {\n                event.ports[0].postMessage({ success: true });\n            });\n            break;\n            \n        default:\n            console.warn('Unknown message type:', type);\n    }\n});\n\n/**\n * Get cache size for debugging/monitoring\n */\nasync function getCacheSize() {\n    const cache = await caches.open(CACHE_NAME);\n    const requests = await cache.keys();\n    let totalSize = 0;\n    \n    for (const request of requests) {\n        const response = await cache.match(request);\n        if (response) {\n            const blob = await response.blob();\n            totalSize += blob.size;\n        }\n    }\n    \n    return totalSize;\n}\n\n/**\n * Clear all caches\n */\nasync function clearCache() {\n    const cacheNames = await caches.keys();\n    return Promise.all(\n        cacheNames.map(name => caches.delete(name))\n    );\n}\n\nconsole.log('üç∑ VinsDelux Service Worker loaded successfully');"