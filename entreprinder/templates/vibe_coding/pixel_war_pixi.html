{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% load vite_tags %}

{% block title %}{% trans "Pixel War - PixiJS" %}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'powerup/css/pages/pixel_war.css' %}">
<style>
    #canvas-container {
        position: relative;
        width: 100%;
        height: 600px;
        overflow: hidden;
    }
    
    #canvas-container canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
        <div class="col-12">
            <h2>{% trans "Pixel War - PixiJS Version" %}</h2>
            <div class="alert alert-success">
                <strong>WebGL Accelerated:</strong> 10-100x faster performance with GPU rendering
            </div>
        </div>
    </div>
    
    <div class="row">
        <div class="col-lg-9">
            <div id="canvas-container"></div>
        </div>
        
        <div class="col-lg-3">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">{% trans "Color Palette" %}</h5>
                    <div class="color-palette">
                        <button class="color-btn active" data-color="#000000" style="background: #000000;"></button>
                        <button class="color-btn" data-color="#FFFFFF" style="background: #FFFFFF;"></button>
                        <button class="color-btn" data-color="#FF0000" style="background: #FF0000;"></button>
                        <button class="color-btn" data-color="#00FF00" style="background: #00FF00;"></button>
                        <button class="color-btn" data-color="#0000FF" style="background: #0000FF;"></button>
                        <button class="color-btn" data-color="#FFFF00" style="background: #FFFF00;"></button>
                        <button class="color-btn" data-color="#FF00FF" style="background: #FF00FF;"></button>
                        <button class="color-btn" data-color="#00FFFF" style="background: #00FFFF;"></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- PixiJS from CDN -->
{% vite_preload_deps %}
{% vite_asset 'pixel-war-pixi' %}

<script type="module">
class PixelWarPixi {
    constructor(containerId, config) {
        this.config = config;
        this.container = document.getElementById(containerId);
        this.selectedColor = '#000000';
        
        // PixiJS Application
        this.app = new PIXI.Application({
            width: this.container.offsetWidth,
            height: 600,
            backgroundColor: 0xffffff,
            antialias: false,
            resolution: window.devicePixelRatio || 1
        });
        
        this.container.appendChild(this.app.view);
        
        // Viewport for pan/zoom
        this.viewport = new pixi_viewport.Viewport({
            screenWidth: this.container.offsetWidth,
            screenHeight: 600,
            worldWidth: config.width * 10,
            worldHeight: config.height * 10,
            interaction: this.app.renderer.plugins.interaction
        });
        
        // Configure viewport
        this.viewport
            .drag()
            .pinch()
            .wheel()
            .decelerate({ friction: 0.95 })
            .clamp({ left: 0, right: config.width * 10, top: 0, bottom: config.height * 10 })
            .clampZoom({ minScale: 0.5, maxScale: 10 });
        
        this.app.stage.addChild(this.viewport);
        
        // Containers
        this.pixelContainer = new PIXI.Container();
        this.viewport.addChild(this.pixelContainer);
        
        this.gridGraphics = new PIXI.Graphics();
        this.viewport.addChild(this.gridGraphics);
        
        // Click handler
        this.viewport.on('clicked', (e) => this.handlePixelClick(e));
        
        // Navigation buttons
        this.setupNavigationButtons();
        
        // Load pixels
        this.pixels = {};
        this.loadCanvasState();
        
        // Update loop
        this.app.ticker.add(() => this.update());
        
        // Poll for updates
        setInterval(() => this.loadCanvasState(), 2000);
    }
    
    setupNavigationButtons() {
        const navHTML = `
            <div class="pixi-nav-buttons" style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 1000;">
                <button class="btn btn-sm btn-light" onclick="pixelWar.navigateToCorner('top-left')">↖️</button>
                <button class="btn btn-sm btn-light" onclick="pixelWar.navigateToCorner('top-right')">↗️</button>
                <button class="btn btn-sm btn-light" onclick="pixelWar.navigateToCorner('center')">⊙</button>
                <button class="btn btn-sm btn-light" onclick="pixelWar.navigateToCorner('bottom-left')">↙️</button>
                <button class="btn btn-sm btn-light" onclick="pixelWar.navigateToCorner('bottom-right')">↘️</button>
            </div>
        `;
        this.container.insertAdjacentHTML('beforeend', navHTML);
    }
    
    navigateToCorner(corner) {
        const positions = {
            'top-left': { x: 50, y: 50 },
            'top-right': { x: this.config.width * 10 - 50, y: 50 },
            'bottom-left': { x: 50, y: this.config.height * 10 - 50 },
            'bottom-right': { x: this.config.width * 10 - 50, y: this.config.height * 10 - 50 },
            'center': { x: this.config.width * 5, y: this.config.height * 5 }
        };
        
        const target = positions[corner];
        if (target) {
            this.viewport.animate({
                position: target,
                scale: 2,
                time: 500
            });
        }
    }
    
    handlePixelClick(e) {
        const point = e.world;
        const gridX = Math.floor(point.x / 10);
        const gridY = Math.floor(point.y / 10);
        
        if (gridX >= 0 && gridX < this.config.width && gridY >= 0 && gridY < this.config.height) {
            this.placePixel(gridX, gridY);
        }
    }
    
    placePixel(x, y) {
        fetch('/vibe-coding/api/place-pixel/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
            },
            body: JSON.stringify({
                canvas_id: this.config.canvasId,
                x: x,
                y: y,
                color: this.selectedColor
            })
        })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                this.drawPixel(x, y, this.selectedColor);
            }
        });
    }
    
    drawPixel(x, y, color) {
        const key = `${x},${y}`;
        
        // Remove old pixel if exists
        if (this.pixels[key]) {
            this.pixelContainer.removeChild(this.pixels[key]);
        }
        
        // Create new pixel sprite
        const pixel = new PIXI.Graphics();
        pixel.beginFill(parseInt(color.replace('#', '0x')));
        pixel.drawRect(x * 10, y * 10, 10, 10);
        pixel.endFill();
        
        this.pixelContainer.addChild(pixel);
        this.pixels[key] = pixel;
    }
    
    loadCanvasState() {
        fetch(`/vibe-coding/api/canvas-state/${this.config.canvasId}/`)
            .then(res => res.json())
            .then(data => {
                Object.entries(data.pixels).forEach(([key, pixel]) => {
                    const [x, y] = key.split(',').map(Number);
                    this.drawPixel(x, y, pixel.color);
                });
            });
    }
    
    update() {
        // Update grid visibility based on zoom
        const showGrid = this.viewport.scale.x > 2;
        if (showGrid && !this.gridVisible) {
            this.drawGrid();
            this.gridVisible = true;
        } else if (!showGrid && this.gridVisible) {
            this.gridGraphics.clear();
            this.gridVisible = false;
        }
    }
    
    drawGrid() {
        const g = this.gridGraphics;
        g.clear();
        g.lineStyle(0.5, 0xcccccc, 0.3);
        
        for (let x = 0; x <= this.config.width * 10; x += 10) {
            g.moveTo(x, 0);
            g.lineTo(x, this.config.height * 10);
        }
        
        for (let y = 0; y <= this.config.height * 10; y += 10) {
            g.moveTo(0, y);
            g.lineTo(this.config.width * 10, y);
        }
    }
}

// Initialize
const config = {
    width: {{ canvas.width }},
    height: {{ canvas.height }},
    canvasId: {{ canvas.id }},
    isAuthenticated: {{ user.is_authenticated|lower }}
};

const pixelWar = new PixelWarPixi('canvas-container', config);

// Color selection
document.querySelectorAll('.color-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        pixelWar.selectedColor = btn.dataset.color;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    });
});
</script>

{% csrf_token %}
{% endblock %}