"""
Event check-in API endpoint.

Handles QR code scans from coaches at event entrances. The QR code contains
a signed URL with the registration ID and token. When scanned, this endpoint
verifies the token and marks the registration as attended.
"""

import logging

from django.conf import settings
from django.core.signing import BadSignature, Signer
from django.http import JsonResponse
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST

from .models import EventRegistration

logger = logging.getLogger(__name__)


@csrf_exempt
@require_POST
def event_checkin_api(request, registration_id, token):
    """
    Check in an attendee via signed QR code token.

    The token is generated by Django's Signer and encodes
    "{registration_id}:{event_id}". This endpoint:

    1. Verifies the signed token
    2. Validates registration exists and is confirmed
    3. Checks the event is within the check-in window (default: 12 hours)
    4. Marks registration as attended with checked_in_at timestamp
    5. Returns JSON with attendee name and success status
    """
    # Verify token
    signer = Signer()
    try:
        unsigned = signer.unsign(token)
    except BadSignature:
        logger.warning("Invalid check-in token for registration %s", registration_id)
        return JsonResponse(
            {"success": False, "error": "Invalid or expired check-in token."},
            status=400,
        )

    # Parse token payload
    try:
        token_reg_id, token_event_id = unsigned.split(":")
        token_reg_id = int(token_reg_id)
        token_event_id = int(token_event_id)
    except (ValueError, AttributeError):
        return JsonResponse(
            {"success": False, "error": "Malformed check-in token."},
            status=400,
        )

    # Verify token matches URL
    if token_reg_id != registration_id:
        return JsonResponse(
            {"success": False, "error": "Token does not match registration."},
            status=400,
        )

    # Fetch registration
    try:
        registration = EventRegistration.objects.select_related(
            "event", "user", "user__crushprofile"
        ).get(id=registration_id)
    except EventRegistration.DoesNotExist:
        return JsonResponse(
            {"success": False, "error": "Registration not found."},
            status=404,
        )

    # Verify event ID matches
    if registration.event_id != token_event_id:
        return JsonResponse(
            {"success": False, "error": "Token does not match event."},
            status=400,
        )

    # Check if already attended
    if registration.status == "attended":
        display_name = _get_display_name(registration)
        return JsonResponse({
            "success": True,
            "already_checked_in": True,
            "attendee_name": display_name,
            "checked_in_at": registration.checked_in_at.isoformat() if registration.checked_in_at else None,
            "message": f"{display_name} was already checked in.",
        })

    # Verify status is confirmed
    if registration.status != "confirmed":
        return JsonResponse(
            {
                "success": False,
                "error": f"Registration status is '{registration.get_status_display()}'. Only confirmed registrations can be checked in.",
            },
            status=400,
        )

    # Check event is within check-in window
    checkin_window_hours = getattr(settings, "EVENT_CHECKIN_WINDOW_HOURS", 12)
    now = timezone.now()
    event_start = registration.event.date_time
    from datetime import timedelta

    window_start = event_start - timedelta(hours=checkin_window_hours)
    window_end = event_start + timedelta(hours=checkin_window_hours)

    if not (window_start <= now <= window_end):
        return JsonResponse(
            {
                "success": False,
                "error": f"Check-in is only available within {checkin_window_hours} hours of the event.",
            },
            status=400,
        )

    # Mark as attended
    registration.status = "attended"
    registration.checked_in_at = now
    registration.save(update_fields=["status", "checked_in_at", "updated_at"])

    display_name = _get_display_name(registration)

    logger.info(
        "Checked in registration %s (user %s) for event %s",
        registration.id,
        registration.user_id,
        registration.event_id,
    )

    return JsonResponse({
        "success": True,
        "already_checked_in": False,
        "attendee_name": display_name,
        "checked_in_at": now.isoformat(),
        "message": f"{display_name} has been checked in!",
    })


def _get_display_name(registration):
    """Get privacy-aware display name for attendee."""
    try:
        return registration.user.crushprofile.display_name
    except Exception:
        return registration.user.first_name or registration.user.username
