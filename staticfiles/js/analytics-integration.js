/**\n * VinsDelux Analytics Integration Module\n * Implements luxury-grade analytics and performance monitoring\n * with privacy-compliant tracking and user experience insights\n */\n\nclass VinsDeluxAnalytics {\n    constructor() {\n        this.isInitialized = false;\n        this.hasConsent = this.checkAnalyticsConsent();\n        this.sessionId = this.generateSessionId();\n        this.startTime = performance.now();\n        this.interactions = [];\n        this.performanceMetrics = {};\n        this.userJourney = [];\n        \n        // Privacy-first approach\n        if (this.hasConsent) {\n            this.init();\n        } else {\n            this.initPrivacyCompliantTracking();\n        }\n    }\n    \n    init() {\n        this.isInitialized = true;\n        \n        // Initialize tracking services\n        this.setupGoogleAnalytics();\n        this.setupUserInteractionTracking();\n        this.setupPerformanceMonitoring();\n        this.setupErrorTracking();\n        this.setupConversionTracking();\n        this.setupHeatmapTracking();\n        \n        console.log('ðŸ· VinsDelux Analytics initialized with user consent');\n    }\n    \n    initPrivacyCompliantTracking() {\n        // Minimal, privacy-compliant tracking without cookies\n        this.setupAnonymousMetrics();\n        this.setupBasicPerformanceMonitoring();\n        \n        console.log('ðŸ”’ VinsDelux Privacy-compliant Analytics initialized');\n    }\n    \n    /**\n     * Google Analytics 4 Integration\n     */\n    setupGoogleAnalytics() {\n        if (!this.hasConsent) return;\n        \n        // Load gtag.js\n        const script = document.createElement('script');\n        script.async = true;\n        script.src = `https://www.googletagmanager.com/gtag/js?id=${window.GA_MEASUREMENT_ID || 'G-XXXXXXXXXX'}`;\n        document.head.appendChild(script);\n        \n        // Initialize gtag\n        window.dataLayer = window.dataLayer || [];\n        function gtag(){dataLayer.push(arguments);}\n        window.gtag = gtag;\n        \n        gtag('js', new Date());\n        gtag('config', window.GA_MEASUREMENT_ID || 'G-XXXXXXXXXX', {\n            page_title: document.title,\n            page_location: window.location.href,\n            custom_map: {\n                'custom_parameter_1': 'vineyard_region',\n                'custom_parameter_2': 'plot_selection_step',\n                'custom_parameter_3': 'adoption_plan_type'\n            }\n        });\n        \n        // Enhanced ecommerce for wine adoption tracking\n        this.setupEcommerceTracking();\n    }\n    \n    setupEcommerceTracking() {\n        // Track plot selection as product views\n        window.trackPlotView = (plot) => {\n            if (!this.hasConsent) return;\n            \n            gtag('event', 'view_item', {\n                currency: 'EUR',\n                value: parseFloat(plot.base_price),\n                items: [{\n                    item_id: plot.plot_identifier,\n                    item_name: plot.name,\n                    item_category: 'Vineyard Plot',\n                    item_brand: plot.producer.name,\n                    item_variant: plot.grape_varieties.join(', '),\n                    price: parseFloat(plot.base_price),\n                    quantity: 1\n                }]\n            });\n        };\n        \n        // Track plot selection (add to cart equivalent)\n        window.trackPlotSelection = (plot) => {\n            if (!this.hasConsent) return;\n            \n            gtag('event', 'add_to_cart', {\n                currency: 'EUR',\n                value: parseFloat(plot.base_price),\n                items: [{\n                    item_id: plot.plot_identifier,\n                    item_name: plot.name,\n                    item_category: 'Vineyard Plot',\n                    item_brand: plot.producer.name,\n                    price: parseFloat(plot.base_price),\n                    quantity: 1\n                }]\n            });\n        };\n        \n        // Track adoption plan purchase\n        window.trackAdoption = (plots, adoptionPlan) => {\n            if (!this.hasConsent) return;\n            \n            const items = plots.map(plot => ({\n                item_id: plot.plot_identifier,\n                item_name: plot.name,\n                item_category: 'Vineyard Plot',\n                item_brand: plot.producer.name,\n                price: parseFloat(plot.base_price),\n                quantity: 1\n            }));\n            \n            gtag('event', 'purchase', {\n                transaction_id: `adoption_${Date.now()}`,\n                value: items.reduce((sum, item) => sum + item.price, 0),\n                currency: 'EUR',\n                items: items\n            });\n        };\n    }\n    \n    /**\n     * User Interaction Tracking\n     */\n    setupUserInteractionTracking() {\n        // Plot interaction tracking\n        this.trackPlotInteractions();\n        \n        // Journey step tracking\n        this.trackJourneyProgress();\n        \n        // Search and filter tracking\n        this.trackSearchAndFilters();\n        \n        // Engagement metrics\n        this.trackEngagementMetrics();\n    }\n    \n    trackPlotInteractions() {\n        // Track plot clicks/selections\n        document.addEventListener('click', (event) => {\n            if (event.target.closest('.plot-marker, .plot-card')) {\n                const plotElement = event.target.closest('.plot-marker, .plot-card');\n                const plotId = plotElement.dataset.plotId || plotElement.id;\n                \n                this.trackEvent('plot_interaction', {\n                    plot_id: plotId,\n                    interaction_type: 'click',\n                    timestamp: Date.now(),\n                    page_section: this.getCurrentSection()\n                });\n            }\n        });\n        \n        // Track hover events for engagement analysis\n        document.addEventListener('mouseenter', (event) => {\n            if (event.target.closest('.plot-marker')) {\n                const plotElement = event.target.closest('.plot-marker');\n                const plotId = plotElement.dataset.plotId;\n                \n                this.trackEvent('plot_hover', {\n                    plot_id: plotId,\n                    timestamp: Date.now()\n                }, false); // Don't send to GA for hover events\n            }\n        }, true);\n    }\n    \n    trackJourneyProgress() {\n        // Track progress through the adoption journey\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting && entry.intersectionRatio > 0.5) {\n                    const stepElement = entry.target;\n                    const stepNumber = stepElement.dataset.step || 'unknown';\n                    \n                    this.userJourney.push({\n                        step: stepNumber,\n                        timestamp: Date.now(),\n                        timeOnPrevious: this.getTimeOnCurrentStep()\n                    });\n                    \n                    this.trackEvent('journey_progress', {\n                        step: stepNumber,\n                        previous_steps: this.userJourney.length - 1,\n                        time_to_reach: Date.now() - this.startTime\n                    });\n                }\n            });\n        }, { threshold: 0.5 });\n        \n        // Observe journey step elements\n        document.querySelectorAll('[data-step]').forEach(el => {\n            observer.observe(el);\n        });\n    }\n    \n    trackSearchAndFilters() {\n        // Track search queries\n        document.addEventListener('input', (event) => {\n            if (event.target.matches('input[type=\"search\"], .search-input')) {\n                const query = event.target.value;\n                if (query.length >= 3) {\n                    this.debounce(() => {\n                        this.trackEvent('search_query', {\n                            query: this.hashString(query), // Hash for privacy\n                            results_count: this.getSearchResultsCount(),\n                            timestamp: Date.now()\n                        });\n                    }, 1000)();\n                }\n            }\n        });\n        \n        // Track filter usage\n        document.addEventListener('change', (event) => {\n            if (event.target.matches('select, input[type=\"radio\"], input[type=\"checkbox\"]')) {\n                const filterType = event.target.name || event.target.className;\n                const filterValue = event.target.value || event.target.checked;\n                \n                this.trackEvent('filter_used', {\n                    filter_type: filterType,\n                    filter_value: filterValue,\n                    timestamp: Date.now()\n                });\n            }\n        });\n    }\n    \n    trackEngagementMetrics() {\n        // Scroll depth tracking\n        let maxScroll = 0;\n        window.addEventListener('scroll', this.throttle(() => {\n            const scrollPercent = Math.round(\n                (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100\n            );\n            \n            if (scrollPercent > maxScroll) {\n                maxScroll = scrollPercent;\n                \n                // Track significant scroll milestones\n                if ([25, 50, 75, 90].includes(scrollPercent)) {\n                    this.trackEvent('scroll_depth', {\n                        percent: scrollPercent,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n        }, 1000));\n        \n        // Time on page tracking\n        this.startPageTimer();\n        \n        // Rage click detection\n        this.setupRageClickDetection();\n    }\n    \n    /**\n     * Performance Monitoring\n     */\n    setupPerformanceMonitoring() {\n        // Web Vitals tracking\n        this.trackWebVitals();\n        \n        // Custom performance metrics\n        this.trackCustomMetrics();\n        \n        // Resource loading performance\n        this.trackResourcePerformance();\n    }\n    \n    trackWebVitals() {\n        if ('PerformanceObserver' in window) {\n            // Largest Contentful Paint\n            const lcpObserver = new PerformanceObserver((list) => {\n                const entries = list.getEntries();\n                const lastEntry = entries[entries.length - 1];\n                \n                this.performanceMetrics.lcp = lastEntry.startTime;\n                this.trackEvent('web_vitals_lcp', {\n                    value: Math.round(lastEntry.startTime),\n                    rating: this.getLCPRating(lastEntry.startTime)\n                });\n            });\n            \n            try {\n                lcpObserver.observe({entryTypes: ['largest-contentful-paint']});\n            } catch (e) {\n                console.warn('LCP observation not supported:', e);\n            }\n            \n            // First Input Delay\n            const fidObserver = new PerformanceObserver((list) => {\n                const entries = list.getEntries();\n                entries.forEach(entry => {\n                    const fid = entry.processingStart - entry.startTime;\n                    this.performanceMetrics.fid = fid;\n                    \n                    this.trackEvent('web_vitals_fid', {\n                        value: Math.round(fid),\n                        rating: this.getFIDRating(fid)\n                    });\n                });\n            });\n            \n            try {\n                fidObserver.observe({entryTypes: ['first-input']});\n            } catch (e) {\n                console.warn('FID observation not supported:', e);\n            }\n            \n            // Cumulative Layout Shift\n            let clsValue = 0;\n            const clsObserver = new PerformanceObserver((list) => {\n                const entries = list.getEntries();\n                entries.forEach(entry => {\n                    if (!entry.hadRecentInput) {\n                        clsValue += entry.value;\n                    }\n                });\n                \n                this.performanceMetrics.cls = clsValue;\n            });\n            \n            try {\n                clsObserver.observe({entryTypes: ['layout-shift']});\n            } catch (e) {\n                console.warn('CLS observation not supported:', e);\n            }\n            \n            // Send CLS on page unload\n            window.addEventListener('beforeunload', () => {\n                if (clsValue > 0) {\n                    this.trackEvent('web_vitals_cls', {\n                        value: Math.round(clsValue * 1000) / 1000,\n                        rating: this.getCLSRating(clsValue)\n                    });\n                }\n            });\n        }\n    }\n    \n    trackCustomMetrics() {\n        // Time to interactive\n        window.addEventListener('load', () => {\n            setTimeout(() => {\n                const tti = this.calculateTTI();\n                if (tti) {\n                    this.trackEvent('time_to_interactive', {\n                        value: Math.round(tti),\n                        timestamp: Date.now()\n                    });\n                }\n            }, 5000);\n        });\n        \n        // Map load time\n        if (window.L) {\n            const mapStartTime = performance.now();\n            window.addEventListener('mapready', () => {\n                const mapLoadTime = performance.now() - mapStartTime;\n                this.trackEvent('map_load_time', {\n                    value: Math.round(mapLoadTime),\n                    timestamp: Date.now()\n                });\n            });\n        }\n    }\n    \n    /**\n     * Error Tracking\n     */\n    setupErrorTracking() {\n        // JavaScript errors\n        window.addEventListener('error', (event) => {\n            this.trackError('javascript_error', {\n                message: event.message,\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno,\n                stack: event.error?.stack,\n                user_agent: navigator.userAgent,\n                timestamp: Date.now()\n            });\n        });\n        \n        // Unhandled promise rejections\n        window.addEventListener('unhandledrejection', (event) => {\n            this.trackError('unhandled_promise_rejection', {\n                reason: event.reason,\n                timestamp: Date.now()\n            });\n        });\n        \n        // Network errors\n        this.setupNetworkErrorTracking();\n    }\n    \n    setupNetworkErrorTracking() {\n        const originalFetch = window.fetch;\n        window.fetch = async (...args) => {\n            const startTime = performance.now();\n            \n            try {\n                const response = await originalFetch(...args);\n                const endTime = performance.now();\n                \n                // Track successful API calls\n                if (args[0].includes('/api/')) {\n                    this.trackEvent('api_call_success', {\n                        endpoint: this.sanitizeURL(args[0]),\n                        duration: Math.round(endTime - startTime),\n                        status: response.status\n                    });\n                }\n                \n                // Track failed requests\n                if (!response.ok) {\n                    this.trackError('network_error', {\n                        endpoint: this.sanitizeURL(args[0]),\n                        status: response.status,\n                        statusText: response.statusText,\n                        duration: Math.round(endTime - startTime)\n                    });\n                }\n                \n                return response;\n            } catch (error) {\n                const endTime = performance.now();\n                \n                this.trackError('fetch_error', {\n                    endpoint: this.sanitizeURL(args[0]),\n                    error: error.message,\n                    duration: Math.round(endTime - startTime)\n                });\n                \n                throw error;\n            }\n        };\n    }\n    \n    /**\n     * Conversion Tracking\n     */\n    setupConversionTracking() {\n        // Track plot selection funnel\n        this.trackFunnelStep('plot_page_visit');\n        \n        // Track selection completions\n        document.addEventListener('plotselected', (event) => {\n            this.trackFunnelStep('plot_selected', {\n                plot_count: event.detail.plotCount,\n                total_value: event.detail.totalValue\n            });\n        });\n        \n        // Track adoption plan views\n        document.addEventListener('adoptionplanview', (event) => {\n            this.trackFunnelStep('adoption_plan_viewed', {\n                plan_id: event.detail.planId,\n                plan_price: event.detail.planPrice\n            });\n        });\n    }\n    \n    /**\n     * Heatmap and User Behavior Tracking\n     */\n    setupHeatmapTracking() {\n        if (!this.hasConsent) return;\n        \n        // Click heatmap data\n        document.addEventListener('click', (event) => {\n            const rect = event.target.getBoundingClientRect();\n            const clickData = {\n                x: Math.round(event.clientX),\n                y: Math.round(event.clientY),\n                element: event.target.tagName.toLowerCase(),\n                className: event.target.className,\n                viewport_width: window.innerWidth,\n                viewport_height: window.innerHeight,\n                timestamp: Date.now()\n            };\n            \n            this.sendHeatmapData('click', clickData);\n        });\n        \n        // Mouse movement heatmap (sampled)\n        let mouseMoveCount = 0;\n        document.addEventListener('mousemove', (event) => {\n            mouseMoveCount++;\n            \n            // Sample every 100th mouse move\n            if (mouseMoveCount % 100 === 0) {\n                const moveData = {\n                    x: Math.round(event.clientX),\n                    y: Math.round(event.clientY),\n                    timestamp: Date.now()\n                };\n                \n                this.sendHeatmapData('mousemove', moveData);\n            }\n        });\n    }\n    \n    /**\n     * Privacy-Compliant Anonymous Metrics\n     */\n    setupAnonymousMetrics() {\n        // Basic page performance without personal data\n        this.trackAnonymousPageLoad();\n        \n        // Anonymous interaction patterns\n        this.trackAnonymousInteractions();\n    }\n    \n    trackAnonymousPageLoad() {\n        window.addEventListener('load', () => {\n            const timing = performance.getEntriesByType('navigation')[0];\n            \n            this.sendAnonymousMetric('page_load', {\n                load_time: Math.round(timing.loadEventEnd - timing.navigationStart),\n                dom_content_loaded: Math.round(timing.domContentLoadedEventEnd - timing.navigationStart),\n                first_paint: this.getFirstPaint(),\n                connection_type: navigator.connection?.effectiveType || 'unknown'\n            });\n        });\n    }\n    \n    /**\n     * Utility Methods\n     */\n    trackEvent(eventName, parameters = {}, sendToGA = true) {\n        // Store event locally\n        this.interactions.push({\n            event: eventName,\n            parameters: parameters,\n            timestamp: Date.now(),\n            session_id: this.sessionId\n        });\n        \n        // Send to Google Analytics if consent given\n        if (this.hasConsent && sendToGA && window.gtag) {\n            gtag('event', eventName, parameters);\n        }\n        \n        // Send to custom analytics endpoint\n        this.sendCustomAnalytics(eventName, parameters);\n    }\n    \n    trackError(errorType, errorData) {\n        console.error('Analytics Error Tracked:', errorType, errorData);\n        \n        this.trackEvent('error_occurred', {\n            error_type: errorType,\n            ...errorData\n        });\n    }\n    \n    trackFunnelStep(stepName, additionalData = {}) {\n        this.trackEvent('funnel_step', {\n            step_name: stepName,\n            step_index: this.getFunnelStepIndex(stepName),\n            session_duration: Date.now() - this.startTime,\n            ...additionalData\n        });\n    }\n    \n    sendCustomAnalytics(eventName, parameters) {\n        // Send to custom analytics endpoint\n        if (navigator.sendBeacon) {\n            const data = {\n                event: eventName,\n                parameters: parameters,\n                timestamp: Date.now(),\n                session_id: this.sessionId,\n                user_agent: navigator.userAgent,\n                url: window.location.href\n            };\n            \n            navigator.sendBeacon('/analytics/track/', JSON.stringify(data));\n        }\n    }\n    \n    sendHeatmapData(type, data) {\n        // Send heatmap data to collection endpoint\n        if (this.hasConsent && navigator.sendBeacon) {\n            navigator.sendBeacon('/analytics/heatmap/', JSON.stringify({\n                type: type,\n                data: data,\n                session_id: this.sessionId,\n                page_url: window.location.pathname\n            }));\n        }\n    }\n    \n    sendAnonymousMetric(metricName, data) {\n        // Send anonymous metrics without personal identification\n        if (navigator.sendBeacon) {\n            navigator.sendBeacon('/analytics/anonymous/', JSON.stringify({\n                metric: metricName,\n                data: data,\n                timestamp: Date.now()\n            }));\n        }\n    }\n    \n    // Helper methods\n    checkAnalyticsConsent() {\n        return localStorage.getItem('analytics-consent') === 'true' ||\n               document.cookie.includes('analytics-consent=true');\n    }\n    \n    generateSessionId() {\n        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    }\n    \n    hashString(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n    \n    sanitizeURL(url) {\n        // Remove sensitive parameters from URLs\n        try {\n            const urlObj = new URL(url, window.location.origin);\n            urlObj.searchParams.delete('token');\n            urlObj.searchParams.delete('session');\n            urlObj.searchParams.delete('user');\n            return urlObj.pathname;\n        } catch (e) {\n            return url.split('?')[0]; // Fallback\n        }\n    }\n    \n    getCurrentSection() {\n        const sections = document.querySelectorAll('section[id]');\n        const scrollY = window.scrollY + window.innerHeight / 2;\n        \n        for (const section of sections) {\n            const rect = section.getBoundingClientRect();\n            const absoluteTop = rect.top + window.scrollY;\n            const absoluteBottom = absoluteTop + rect.height;\n            \n            if (scrollY >= absoluteTop && scrollY <= absoluteBottom) {\n                return section.id;\n            }\n        }\n        \n        return 'unknown';\n    }\n    \n    getTimeOnCurrentStep() {\n        const lastStep = this.userJourney[this.userJourney.length - 1];\n        return lastStep ? Date.now() - lastStep.timestamp : 0;\n    }\n    \n    getFunnelStepIndex(stepName) {\n        const steps = [\n            'plot_page_visit',\n            'plot_selected',\n            'adoption_plan_viewed',\n            'adoption_confirmed',\n            'payment_completed'\n        ];\n        \n        return steps.indexOf(stepName) + 1;\n    }\n    \n    getLCPRating(lcp) {\n        if (lcp <= 2500) return 'good';\n        if (lcp <= 4000) return 'needs_improvement';\n        return 'poor';\n    }\n    \n    getFIDRating(fid) {\n        if (fid <= 100) return 'good';\n        if (fid <= 300) return 'needs_improvement';\n        return 'poor';\n    }\n    \n    getCLSRating(cls) {\n        if (cls <= 0.1) return 'good';\n        if (cls <= 0.25) return 'needs_improvement';\n        return 'poor';\n    }\n    \n    getFirstPaint() {\n        const paintEntries = performance.getEntriesByType('paint');\n        const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');\n        return firstPaint ? Math.round(firstPaint.startTime) : null;\n    }\n    \n    calculateTTI() {\n        // Simplified TTI calculation\n        const timing = performance.getEntriesByType('navigation')[0];\n        return timing ? timing.domContentLoadedEventEnd - timing.navigationStart : null;\n    }\n    \n    getSearchResultsCount() {\n        const results = document.querySelectorAll('.search-result, .plot-card, .adoption-plan-card');\n        return results.length;\n    }\n    \n    // Utility functions for throttling and debouncing\n    throttle(func, limit) {\n        let inThrottle;\n        return function() {\n            const args = arguments;\n            const context = this;\n            if (!inThrottle) {\n                func.apply(context, args);\n                inThrottle = true;\n                setTimeout(() => inThrottle = false, limit);\n            }\n        };\n    }\n    \n    debounce(func, wait, immediate) {\n        let timeout;\n        return function() {\n            const context = this, args = arguments;\n            const later = function() {\n                timeout = null;\n                if (!immediate) func.apply(context, args);\n            };\n            const callNow = immediate && !timeout;\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n            if (callNow) func.apply(context, args);\n        };\n    }\n    \n    startPageTimer() {\n        this.pageStartTime = Date.now();\n        \n        // Track time on page when leaving\n        window.addEventListener('beforeunload', () => {\n            const timeOnPage = Date.now() - this.pageStartTime;\n            this.trackEvent('time_on_page', {\n                duration: Math.round(timeOnPage / 1000), // in seconds\n                interactions: this.interactions.length,\n                scroll_depth: this.maxScrollDepth || 0\n            });\n        });\n    }\n    \n    setupRageClickDetection() {\n        let clickCount = 0;\n        let clickTimer;\n        let lastClickTarget;\n        \n        document.addEventListener('click', (event) => {\n            if (event.target === lastClickTarget) {\n                clickCount++;\n                \n                if (clickCount === 1) {\n                    clickTimer = setTimeout(() => {\n                        clickCount = 0;\n                        lastClickTarget = null;\n                    }, 2000);\n                } else if (clickCount >= 3) {\n                    // Rage click detected\n                    this.trackEvent('rage_click', {\n                        element: event.target.tagName.toLowerCase(),\n                        className: event.target.className,\n                        click_count: clickCount,\n                        page_section: this.getCurrentSection()\n                    });\n                    \n                    clickCount = 0;\n                    lastClickTarget = null;\n                    clearTimeout(clickTimer);\n                }\n            } else {\n                clickCount = 1;\n                lastClickTarget = event.target;\n                clearTimeout(clickTimer);\n                \n                clickTimer = setTimeout(() => {\n                    clickCount = 0;\n                    lastClickTarget = null;\n                }, 2000);\n            }\n        });\n    }\n    \n    setupBasicPerformanceMonitoring() {\n        // Basic performance monitoring without personal data\n        window.addEventListener('load', () => {\n            const timing = performance.getEntriesByType('navigation')[0];\n            \n            this.sendAnonymousMetric('basic_performance', {\n                load_time: Math.round(timing.loadEventEnd - timing.navigationStart),\n                dom_ready: Math.round(timing.domContentLoadedEventEnd - timing.navigationStart),\n                connection: navigator.connection?.effectiveType || 'unknown',\n                memory: navigator.deviceMemory || 'unknown'\n            });\n        });\n    }\n    \n    /**\n     * Public API\n     */\n    updateConsent(hasConsent) {\n        this.hasConsent = hasConsent;\n        \n        if (hasConsent && !this.isInitialized) {\n            this.init();\n        } else if (!hasConsent && this.isInitialized) {\n            this.cleanup();\n        }\n    }\n    \n    cleanup() {\n        // Remove tracking when consent is withdrawn\n        if (window.gtag) {\n            gtag('consent', 'update', {\n                'analytics_storage': 'denied',\n                'ad_storage': 'denied'\n            });\n        }\n        \n        this.isInitialized = false;\n    }\n    \n    getSessionData() {\n        return {\n            session_id: this.sessionId,\n            interactions: this.interactions.length,\n            performance_metrics: this.performanceMetrics,\n            user_journey: this.userJourney.map(step => ({\n                step: step.step,\n                timestamp: step.timestamp\n            }))\n        };\n    }\n}\n\n// Initialize analytics when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n        window.vinsDeluxAnalytics = new VinsDeluxAnalytics();\n    });\n} else {\n    window.vinsDeluxAnalytics = new VinsDeluxAnalytics();\n}\n\n// Export for module systems\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = VinsDeluxAnalytics;\n}"